# requires -Version 3.0

# SCRIPT IS IN DEVELOPMENT #

<#
        .SYNOPSIS
        Vulnerability management report script 

        .DESCRIPTION
        This script parses .nessus files, and provides a summary report, with implied actions 
        based on aging and severity. This script is currently only concerned with vulnerabilities 
        that have a critical or high rating, or medium rating which can be exploited remotely. 
		
        As this reporting is intended to be the driver of action for the most vulnerable 
        systems in your environment, it only reports on vulns that have an exploit available. 
		
        The purpose of this script is to provide a starting point for a vulnerabily management 
        program at the technical level, and an easly readable report for upper-management,
        board members, and the risk committee to understand where our technical risk resides. 

        .COPYRIGHT
        None. This is just code. Enjoy, modify, and try to make your $env a better place :)

        .AUTHORS
        Chris Masters https://github.com/masters274
		
        .EXAMPLE
        Basic usage. This will take your latest download of Nessus report and output an MS Excel report 
		
        .\Nessus_Vuln_Mgmt.ps1 -InputFile "C:\Users\Me\Downloads\MyLatestNessusScan.nessus"
		
        Note: you should you be able to use the Nessus posh tools by Carlos Perez to run the scan, download it, 
        and provide said file as an arg for this script, then add and email action at the end. This 
        would in turn create a fully automated reporting solution, in conjunction with scheduled task creation 
        of course... 
		
        .EXAMPLE
        Dev usage. Using the debug option prints the variable names, their value, and other data to the screen.
        This is helpful when adding new entries, and don't quite understand how the variable naming convention
        works. 
		
        .\Nessus_Vuln_Mgmt.ps1 -Inputfile "C:\Users\Me\Downloads\MyLatestNessusScan.nessus" `-DebugScript

        .EXAMPLE
        When you're asked to "break-out" certain network objects, like SANs or ATMs, that may end up in another
        group, like Windows or Linux. We now have "SpecialCase" and "SCGroup". SpecialCase would be the name of 
        the Ojbect (e.x. ATM). SCGroup would be an array of type IPAddress.

        Using the SpecialCase will remove the items from, say the Windows servers or workstation reporting. This
        will prevent double-dinging in your output.		
		
        .\Nessus_Vuln_Mgmt.ps1 -InputFile .\MyScan.nessus -SpecialCase 'ATM' -SCGroup $(gc .\atm.txt)

        This command would output a PSObject in table view to the screen. The last row in your list would be
        ATM devices, and their vunlerabilities and respective aging. This command implies that you have a text 
        file with one IP address per line. 

        .\Nessus_Vuln_Mgmt.ps1 -InputFile .\MyScan.nessus -SpecialCase 'ATM' -SCGroup '192.168.1.2','192.168.2.3'

        This command would produce the same results as the forementioned example, we just presented the IP
        addresses in a different way. 

        .DATE
        September 2016

        .MODIFIED
        September 14, 2016

        .NOTES
        This script hates the style guide... Too many bolt-ons to be pretty.
#>

<# 
        CHANGE LOG:

        0.4
        - Script formatting updated for better readability.
        - Added computer count to each category. Category wide, not age or severity specific
        - Fixed logic problem. When not using SpecialCase, OS information didn't make it into the vuln report.
#>

# TODOs:
# COMPLETE: Move all the debug "if" statements to using the debugIt function. 09/30/2016
# TODO: build a list of requirements if any, and check for them.
# TODO: soon to be requirements: add functionality to download and install from Git or Gallery
# TODO: add email alerting (arg)
# DEPRICATED: use Nessus posh scripts to get the latest report based on scan name.(arg)
# COMPLETE: offer CSV, Gridview, or Screen only outputs, but only allow one via logic. 09/30/2016
# TODO: Build MS Excel functionality into script as additional output type. 
# DEPRICATED: DevCleanUp should imply screen only output.
# COMPLETE: Allow for special groups when reporting needs to be broke out for specific visibility. 10/04/2016
# TODO: Add custom debugging where needed.
# COMPLETE: Clean up unused code 10/05/2016
# COMPLETE: Clean up all local variables created by this script. 10/05/2016
# TODO: Avoid double-ding on applications
# COMPLETE: Add new member to vuln report for integer value of risk factor 10/18/2016

	
[CmdletBinding()]
PARAM ( # Arguments for the script
    [Parameter(Mandatory,Position=0)]
    [ValidateScript({Test-Path -Path $_})]
    [Alias('IF')]
    [String]$InputFile,
    [Parameter()]
    [ValidateSet('Excel','CSV','Screen','GridView')] # Select the type of output you require. 
    [String]$OutputType = 'Screen',
    [String]$OutputFile, # Default will be working directory, and whatever the extension needs to be.
    [Alias('SC')]
    [String]$SpecialCase, # Name of your special case group for break out reporting
    [Alias('SG')]
    [ipAddress[]]$SCGroup, # List of special case IPs/devices
    [Alias('Sum')]
    [Switch]$Summary, # Should we export the application summary data as well?
    [Alias('Sys')]
    [Switch]$IncludeSystemCount, # Adds a column to our CSV object. 
    [Switch]$DebugScript

)

# Variables
$scriptVersion = 'Nessus Vulnerability Mangagement Reporter version 0.5'
$baselineLocalVariables = Get-Variable -Scope 0 # everything after this gets cleaned up. 
$dtStartTime = Get-Date # Start the clock
$strDateTime = $(Get-Date -UFormat '%Y%m%d')
$boolDebug = $DebugScript
$boolShouldContinue = $true # Boolean value that is monitored to determine if we should continue the script
if ($boolDebug) {$dtStartTime}
$objVulnReportData = @() # Build an empty hashtable object. This will hold all the goodies.
$arrayExportList = @() # Empty array list to be used later for the CSV summary exporting.
$smtphost = ''
$emailto = ''
$emailfrom = ''
$emailsubject = ''
$dicRiskValue = @{} # Hash table to convert risk strings to integer
$dicRiskValue.Add('none',0)
$dicRiskValue.Add('low',1)
$dicRiskValue.Add('medium',2)
$dicRiskValue.Add('high',3)
$dicRiskValue.Add('critical',4)

Write-Output ('{0}' -f $scriptVersion) # Display our script version information. 

# Functions
Function Invoke-DebugIt { # Used for debugging to screen
    param (
        [string]
        $msg,
        $val
    )
    if ($boolDebug) {
        Write-Host -NoNewLine -f Gray ('{0} : {1} : ' -f (Get-Date -UFormat '%Y%m%d-%H%M%S'), ($msg))
    Write-Host -f Cyan('{0}' -f ($val))}
}


Function Invoke-Snitch { # Function to send an email alert to distro-list
	
    param (
        [string]
        $strMessage
    )
    Send-MailMessage -SmtpServer $smtphost -To $emailto -From $emailfrom -Subject $emailsubject `
        -BodyasHTML "$strMessage"
}

if ($SpecialCase -or $SCGroup) { # Check if special groups will be used. If so, we'll need both params set. 
    
    if (!($SpecialCase -and $SCGroup)) { # Verify they're both set.
        $boolShouldContinu = $false # Discontinue our script execution if only one is set. 
        Write-Error -Message "Missing one of the Special group paramaters. " +
        "Be sure that both -SpecialCase and -SCGroup are set"
    }
    
    Invoke-DebugIt -msg 'Special Case groups are being used' -val 'Both params set'
    Invoke-DebugIt -msg 'Special Case name' -val ('{0}' -f $SpecialCase )
    Invoke-DebugIt -msg 'Special Case IPs' -val ('{0}' -f $($SCGroup -join ' '))
}

# Import the nessus file
Invoke-DebugIt -Msg 'Starting import of file' -Val "$($InputFile)"

$file = Get-ChildItem $InputFile
[xml]$nessusfile = [IO.File]::ReadAllText($file.FullName) # Get-Content too slow... 

$dtElapsedTime = New-TimeSpan $dtStartTime $(Get-Date)

Invoke-DebugIt -Msg 'Finished import of file' -Val "$($InputFile)"
Invoke-DebugIt -Msg 'Elapsed time' -Val "$dtElapsedTime"
Invoke-DebugIt -Msg 'Output type is set to' -Val "$($OutputType)"

if ($OutputType -eq 'CSV' -or $OutputType -eq 'Excel') {
    
    Invoke-DebugIt -Msg 'Data will output to' -Val "$($OutputFile)" 
}

# scan date information from the InputFile
$strScanTime = $nessusfile.NessusClientData_v2.Report.ReportHost.HostProperties.tag |
    Where-Object {$_.name -eq 'HOST_END'} |
    ForEach-Object {$_.'#text'} | Select-Object -First 1
    
[datetime]$dtScanTime = ('{0}/{1}/{2} {3}' -f 
    ($strScanTime.Split(' ')[1]), ($strScanTime.Split(' ')[2]), 
    ($strScanTime.Split(' ')[4]), ($strScanTime.Split(' ')[3])
)

# We'll report this for the month to have consistency across all report outputs.
$dtScanDate = Get-Date("$($dtScanTime.Month)/1/$($dtScanTime.Year)") -UFormat '%Y%m%d'

Invoke-DebugIt -Msg 'Date of scan' -Val ('{0}' -f $dtScanTime)
Invoke-DebugIt -Msg 'Report date for scan' -Val ('{0}' -f $dtScanDate)
Invoke-DebugIt -Msg 'Begin for loop on XML object' -Val ('{0}' -f $InputFile)


# Loop thru the hosts to build some reporting
foreach ($objHost in $nessusfile.NessusClientData_v2.Report.ReportHost) {

    # Get all the critical and high report items in the test object
    $reportItems = $objHost.ReportItem |
        Where-Object {($_.risk_factor -match 'High|Critical' -or `
            ($_.plugin_type -eq 'remote' -and $_.risk_factor -eq 'Medium')) -and $_.exploit_available -match 'true'
        }

    # Loop thru the items and get needed info from each
    foreach ($item in $reportItems) {

        # Build and PSObject for each of these and add to our hashtable 
        $objBuilder = New-Object PSObject

        # Add the host's properties to the builder object
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'NetBios_Name' -Value `
                "$($objHost.HostProperties.tag | Where-Object {$_.name -eq 'netbios-name'} |
                ForEach-Object{$_.'#text'})"
        
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'FQDN' -Value `
                "$($objHost.HostProperties.tag | Where-Object {$_.name -eq 'host-fqdn'} |
                ForEach-Object{$_.'#text'})"
        
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'IP_Address' -Value `
                "$($objHost.HostProperties.tag | Where-Object {$_.name -eq 'host-ip'} | 
                ForEach-Object{$_.'#text'})"
    
        #========================================================================================================#
        #===================================# APPLICATIONS & SPECIAL CASE #======================================#
        #========================================================================================================#
        
        if ($SpecialCase) { # Check if we need to alter data for applications & special case groups
            [ipAddress]$ipAddress = $($objHost.HostProperties.tag | Where-Object {$_.name -eq 'host-ip'} |
                ForEach-Object{$_.'#text'}
            )
            
            if ($SCGroup -contains $ipAddress) {
                Invoke-DebugIt -msg 'Special Case found' -val ('{0}' -f $ipAddress) # Display dynamic group items.
                
                $objBuilder | 
                    Add-Member -Type NoteProperty -Name 'OS_Family' -Value ('{0}' -f $SpecialCase)
                    
                $objBuilder | 
                    Add-Member -Type NoteProperty -Name 'OS_Name' -Value ('{0}' -f $SpecialCase)
            } 
            else {
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'OS_Family' -Value "$($objHost.HostProperties.tag |
                    Where-Object {$_.name -eq 'os'} | ForEach-Object{$_.'#text'})"
                        
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'OS_Name' -Value "$($objHost.HostProperties.tag |
                    Where-Object {$_.name -eq 'operating-system'} |ForEach-Object{$_.'#text'})"
            }
        }
        else {
            $objBuilder | 
                Add-Member -Type NoteProperty -Name 'OS_Family' -Value "$($objHost.HostProperties.tag |
                    Where-Object {$_.name -eq 'os'} | ForEach-Object{$_.'#text'})"
                        
            $objBuilder | 
                Add-Member -Type NoteProperty -Name 'OS_Name' -Value "$($objHost.HostProperties.tag |
                    Where-Object {$_.name -eq 'operating-system'} |ForEach-Object{$_.'#text'})"
        }
        
        #========================================================================================================#
		
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Credentialed_Scan' -Value "$($objHost.HostProperties.tag |
            Where-Object {$_.name -eq 'Credentialed_Scan'} | ForEach-Object{$_.'#text'})"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'CVE_Count' -Value "$($objHost.HostProperties.tag |
            Where-Object {$_.name -eq 'patch-summary-total-cves'} | ForEach-Object{$_.'#text'})"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Scan_Date' -Value "$($objHost.HostProperties.tag |
            Where-Object {$_.name -eq 'HOST_START'} | ForEach-Object{$_.'#text'})"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'MAC' -Value "$($objHost.HostProperties.tag |
            Where-Object {$_.name -eq 'mac-address'} | ForEach-Object{$_.'#text'})"


        # Add information about the vulns on the host
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Vuln_Name' -Value "$($item.plugin_name)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Vuln_Family' -Value "$($item.pluginFamily)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Risk_Factor' -Value "$($item.risk_factor)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Risk_Value' -Value $dicRiskValue."$($item.risk_factor)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Severity' -Value "$($item.severity)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'CVSS_Base_Score' -Value "$($item.cvss_base_score)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'CVSS_Temporal_Score' -Value "$($item.cvss_temporal_score)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Vuln_Scope' -Value "$($item.plugin_type)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Metasploitable' -Value "$($item.exploit_framework_metasploit)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Exploit_Avail' -Value "$($item.exploit_available)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Exploit_Malware' -Value "$($item.exploited_by_malware)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Vuln_Date' -Value "$($item.vuln_publication_date)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Exploit_Difficulty' -Value "$($item.exploitability_ease)"
            
        $objBuilder | 
            Add-Member -Type NoteProperty -Name 'Solution' -Value "$($item.solution)"

        # Get the age, in days, of the vulnerability
        Try {
            [int]$intVulnAgeInDays = (New-TimeSpan $($item.vuln_publication_date) $(Get-Date)).Days
        } Catch {
            [int]$intVulnAgeInDays = $null
        }
        $objBuilder | Add-Member -Type NoteProperty -Name 'Vuln_Age' -Value $intVulnAgeInDays

        # Append this data to our hashtable
        $objVulnReportData += $objBuilder
    }
}

Invoke-DebugIt -Val 'XML to PSObject Complete'

$dtElapsedTime = New-TimeSpan $dtStartTime $(Get-Date)
Invoke-DebugIt -Msg 'Elapsed time' -Val "$($dtElapsedTime)"



# VULNERABILITY MANAGEMENT SUMMARY REPORTS # 
$intCounter = 0 # Counter used in our while loop thru our 2 dimensional array later
$arrayRiskFactors = ('Critical','High','Medium')

if ($OutputType -eq 'Excel') {
    # XL COLUMN LOOKUP DICTIONARY
    # NOTE: programmatic excel requires that we use R1C1 for cell coordinance
    $dictColumnLookup = @{}
    $dictColumnLookup.Add('Critical30',5)
    $dictColumnLookup.Add('Critical60',8)
    $dictColumnLookup.Add('Critical90',11)
    $dictColumnLookup.Add('Critical91',14)
    $dictColumnLookup.Add('High30',6)
    $dictColumnLookup.Add('High91',15)
    $dictColumnLookup.Add('High90',12)
    $dictColumnLookup.Add('High60',9)
    $dictColumnLookup.Add('Medium30',7)
    $dictColumnLookup.Add('Medium60',10)
    $dictColumnLookup.Add('Medium90',13)
    $dictColumnLookup.Add('Medium91',16)
	
    # TODO: Dynamic row for SpecialCase

    # Let's create an xlsx file so we can put some data in it...

    $xl = New-Object -COM 'Excel.Application'
    $xl.Visible = $boolDebug
    $xl.DisplayAlerts = $false
    $wb = $xl.WorkBooks.Add()
    $ws = $wb.Sheets.Item('Sheet1')
}

# arraySearchList = (os_family , report_category , os_name , vuln_name, XL_Row_Number) use this as the template
# NOTE: using -match, "" is the same as a wild-card search. 
$spoolerList1 = ('Windows','Server','server','',6)
$spoolerList2 = ('Windows','Workstation','Windows 7','',7)
$spoolerList3 = ('Linux','Linux','','',10)
$spoolerList4 = ('','DB2','','db2',8)
$spoolerList5 = ('','Cisco','CISCO IOS','',11)
$spoolerList6 = ('','Java','','java|ibm|websphere',12)
$spoolerList7 = ('','Adobe','','adobe',13)
$spoolerList8 = ('','VMWare','vmware','',14)
$spoolerList9 = ('','MS_SQL','','sql',9)
$spoolerList10 = ('','IBM_Mainframe','IBM OS/400','',15)
	

# NOTE: as you add new searches, be sure to grow the arraySearchList so it gets added in as output. 
$intSpoolerCounter = 1
$boolKeepCounting = $true

while ($boolKeepCounting) { # Let's find out how many vuln types are gonna be in our table.
    if (Invoke-Expression "`$spoolerList$($intSpoolerCounter)") {
        $intSpoolerCounter++
    } else {
        $boolKeepCounting = $false
    }
} # NOTE: This fires one extra time after it's found the last one. We'll need to minus one from the total. 


#================================================================================================================#
#===================================================# SPECIAL CASE #=============================================#
#================================================================================================================#

# Create our array of dynamic information. 

if ($SpecialCase) { # This is about to get weird... checking for dynamic group addition to the spooler list
    # get the highest row number
    # TODO: Make this number dynamic
    [int]$xlRowNumber = 16
	
    # Build any dynamic spooler list items for 'special cases'
    Invoke-Expression -Command ('{0} = ("{1}","{1}","{1}","",{2})' -f "`$spoolerList$($intSpoolerCounter)",
        $SpecialCase,$xlRowNumber)
	
    # While less than this count, get the data for each risk factor
    $intSearchListCountMax = $intSpoolerCounter # Dynamic one added to the list.
} else {
    $intSearchListCountMax = $intSpoolerCounter - 1 # our MAX depends on if we have a dynamic array to add in.
}

#================================================================================================================#


foreach ($intInt in 1..$intSearchListCountMax) { <# NEXT: spit out a list of all the spoolers we just found via 
    the max in our while loop... Replace the arraySearchList contents to grow on its own.#>
    $strSearchListBuilder += ('$spoolerList{0},' -f ($intInt))
} 
$strSearchListBuilder = $strSearchListBuilder -Replace ',$' # Clean up the comma at the end...
Invoke-Expression "`$arraySearchList `= $($strSearchListBuilder)" # 2 dimensional array 


Foreach ($rf in $arrayRiskFactors) { 
    <# 
            This script block creates the dynamic variables with count information, later used to build our CSV
            output object.
            
            Might need to remove the foreach, and just do the while function...
            Loop thru each of the risk ratings and use the counter and invoke expression to solve lots of code 
            with fewer lines. 
    #>

    While ($intCounter -lt $intSearchListCountMax) {
        <#
                we're iterating thru each of the categories and creating a dynamic variable for each. Name based on 
                category name, risk factor name, and age. e.x. $intWindowsServerCriticalCount30
        #>
        
        # Report on 0-30 days
        New-Variable -Name "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])$($rf)Count30" `
        -Value $(			
            $objVulnReportData |
            Where-Object {$_.OS_Name -match "$($arraySearchList[$intCounter][2])" -and $_.OS_Family -match 
                "$($arraySearchList[$intCounter][0])" -and $_.Risk_Factor -eq "$($rf)" -and $_.Vuln_Age -le 30 -and `
            $_.Vuln_Name -match "$($arraySearchList[$intCounter][3])" } |
            Measure-Object |ForEach-Object{$_.Count}
        )
		
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray 
              "$($arraySearchList[$intCounter][0]) $($arraySearchList[$intCounter][1]) " +
              "$($rf) 0-30 days dynamic var name: "
            
            Write-Host -f Cyan 
              "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])$($rf)Count30"
        }
        
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray 'Var value: '
            
            Write-Host -f Cyan 
              ('{0}' -f (
                    Invoke-Expression ('$int{0}{1}{2}Count30' -f ($arraySearchList[$intCounter][0]), 
                        ($arraySearchList[$intCounter][1]), ($rf)
                    )
                )
            )
        }
		
        # Set the data in our spreadsheet
				
        # Report on 31-60 days
        New-Variable -Name "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])$($rf)Count60" `
        -Value $(
            $objVulnReportData |
            Where-Object {$_.OS_Name -match "$($arraySearchList[$intCounter][2])" -and $_.OS_Family -match 
                "$($arraySearchList[$intCounter][0])" -and $_.Risk_Factor -eq "$($rf)" -and $_.Vuln_Age -ge 31 -and `
                $_.Vuln_Age -le 60 -and $_.Vuln_Name -match "$($arraySearchList[$intCounter][3])" } |
            Measure-Object |ForEach-Object{$_.Count}
        )
        
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray "$($arraySearchList[$intCounter][0]) " +
                "$($arraySearchList[$intCounter][1]) $($rf) 31-60 days dynamic var name: "
            
            Write-Host -f Cyan "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])" +
                "$($rf)Count60"
        }
        
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray 'Var value: '
            Write-Host -f Cyan $(
                    Invoke-Expression ('$int{0}{1}{2}Count60' -f ($arraySearchList[$intCounter][0]), 
                        ($arraySearchList[$intCounter][1]), ($rf)
                    )
                )
        }
		
        # Set the data in our spreadsheet
		

        # Report on 61-90 days
        New-Variable -Name "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])$($rf)Count90" `
        -Value $(
            $objVulnReportData |
            Where-Object {$_.OS_Name -match "$($arraySearchList[$intCounter][2])" -and $_.OS_Family -match 
                "$($arraySearchList[$intCounter][0])" -and $_.Risk_Factor -eq "$($rf)" -and $_.Vuln_Age -ge 61 -and `
            $_.Vuln_Age -le 90 -and $_.Vuln_Name -match "$($arraySearchList[$intCounter][3])" } |
            Measure-Object | ForEach-Object{$_.Count}
        )
            
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray "$($arraySearchList[$intCounter][0]) " +
            "$($arraySearchList[$intCounter][1]) $($rf) 61-90 days dynamic var name: "
            
            Write-Host -f Cyan "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])" +
            "$($rf)Count90"
        }
        
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray 'Var value: '
            Write-Host -f Cyan $(
                Invoke-Expression ('$int{0}{1}{2}Count90' -f ($arraySearchList[$intCounter][0]), 
                    ($arraySearchList[$intCounter][1]), ($rf)
                )
            )
        }
		
        # Set the data in our spreadsheet
			
        # Report on > 90 days
        New-Variable -Name "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])$($rf)Count91" `
        -Value $(
            $objVulnReportData |
            Where-Object {$_.OS_Name -match "$($arraySearchList[$intCounter][2])" -and $_.OS_Family -match 
                "$($arraySearchList[$intCounter][0])" -and $_.Risk_Factor -eq "$($rf)" -and $_.Vuln_Age -ge 91 -and `
            $_.Vuln_Name -match "$($arraySearchList[$intCounter][3])" } |
            Measure-Object | ForEach-Object{$_.Count}
        )
        
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray `
            "$($arraySearchList[$intCounter][0]) $($arraySearchList[$intCounter][1]) $($rf) " +
                "91+ days dynamic var name: "
            Write-Host -f Cyan `
                "int$($arraySearchList[$intCounter][0])$($arraySearchList[$intCounter][1])$($rf)Count91"
        }
        if ($boolDebug) {
            Write-Host -NoNewLine -f Gray 'Var value: '
            Write-Host -f Cyan $(
                Invoke-Expression ('$int{0}{1}{2}Count91' -f ($arraySearchList[$intCounter][0]), 
                ($arraySearchList[$intCounter][1]), ($rf))
            )
            
            Write-Host "`n" # Keep it clean with an extra line
        }
		
        # Set the data in our spreadsheet

        
        
        # Get the system count information if it was requested.
        if ($IncludeSystemCount) {
        
        }
        
        
        
        
        # Increment thru all the categories with the current risk factor
        $intCounter++
    }
    # Reset the counter to start over on the new risk factor
    $intCounter = 0
}



if ($OutputType -eq 'CSV' -or $OutputType -eq 'Screen' -or $OutputType -eq 'GridView') { 
    # Add data to our builder object if doing CSV, Screen or Gridview output

    Invoke-DebugIt -Msg 'Begin building CSV object for screen for CSV output. Elapsed time' -Val(
        '{0}' -f ($dtElapsedTime)
    )
	
    foreach ($something in $arraySearchList) { 
        # loop thru all the items in our 2 dimentional array, and add them to an object of export 
		
        $objCsvBuilder = New-Object PSObject
		
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Date' -Value "$dtScanDate"
            
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Category' -Value "$($something[1])"
		
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Critical_30' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount30" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])CriticalCount30" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount30" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'High_30' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])HighCount30" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])HighCount30" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])HighCount30" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Medium_30' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])MediumCount30" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])MediumCount30" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])MediumCount30" )"
		
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Critical_60' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount60" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])CriticalCount60" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount60" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'High_60' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])HighCount60" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])HighCount60" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])HighCount60" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Medium_60' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])MediumCount60" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])MediumCount60" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])MediumCount60" )"
		
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Critical_90' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount90" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])CriticalCount90" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount90" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'High_90' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])HighCount90" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])HighCount90" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])HighCount90" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Medium_90' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])MediumCount90" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])MediumCount90" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])MediumCount90" )"
		
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Critical_91' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount91" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])CriticalCount91" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])CriticalCount91" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'High_91' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])HighCount91" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])HighCount91" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])HighCount91" )"
        
        $objCsvBuilder | 
            Add-Member -Type NoteProperty -Name 'Medium_91' -Value "$( 
                Invoke-Expression "`$int$($something[0])$($something[1])MediumCount91" )"
            
        Invoke-DebugIt -Msg "`$int$($something[0])$($something[1])MediumCount91" -Val "$( 
            Invoke-Expression "`$int$($something[0])$($something[1])MediumCount91" )"
		
        # commit to the CSV object
        $arrayExportList += $objCsvBuilder
    }
	
    if ($OutputType -eq 'Screen') { # Print table to the screen
        $arrayExportList | Format-Table -AutoSize -Property *
    }
    if ($OutputType -eq 'GridView') { # Open a grid view windows with the data.
        $arrayExportList | Out-GridView
    }
    if ($OutputType -eq 'CSV') { # Output the data to CSV file.
        if ($OutputFile.length -lt 1) {
            $OutputFile = ".\$($dtScanDate)_Nessus.csv"
            $arrayExportList | Export-Csv -Path $OutputFile -Append -Encoding ASCII -NoTypeInformation
        }
        $arrayExportList | Export-Csv -Path $OutputFile -Append -Encoding ASCII -NoTypeInformation
    }
}


if ($OutputType -eq 'Excel') { # Save and Close File.
    Invoke-DebugIt -Msg 'Save, close, and release the XL object' -Val 'Begin'
    # $wb.SaveAs($dxls)
    # $wb.Saved = $true
    # $wb.Close()
    # $xl.Quit()
    # [System.Runtime.Interopservices.Marshal]::ReleaseComObject($xl) | Out-Null
    Invoke-DebugIt -Msg 'Save, close, and release the XL object' -Val 'Complete'
}


#--------------------------- # Produce summary data # ---------------------------#

# Get the list of applications we plan to check out
[int]$intSummaryCounter = 0
$arraySummaryList = @()

While ($intSummaryCounter -lt $intSearchListCountMax) {
    # We're only searching for arrayListItems that have an applications (vuln_name) present
    <#
            Example arraySummaryList:

            DB2:db2
            Java:java
            Adobe:adobe
            MS_SQL:sql
    #>
	
    if ($arraySearchList[$intSummaryCounter][3] -ne '') {
        $arraySummaryList += ('{0}:{1}' -f $arraySearchList[$intSummaryCounter][1], 
            $arraySearchList[$intSummaryCounter][3]
        )
    }
	
    $intSummaryCounter++
}


$arraySummaryReport = @()
ForEach ($listItem in $arraySummaryList) {
	
    $objSummaryBuilder = New-Object PSObject
	
    # We'll start with the oldest first. 
    # TODO: If exist in oldest, don't put in the others... per category
    New-Variable -Name ('array{0}Computers61' -f $listItem.Split(':')[0]) -Value $($objVulnReportData | 
        Where-Object {$_.Vuln_Name -match ('{0}' -f $listItem.Split(':')[1]) -and $_.vuln_age -gt 60} |
        ForEach-Object {$_.ip_address} | Sort-Object -Unique
    )
	
    New-Variable -Name ('int{0}Computers61' -f $listItem.Split(':')[0]) -Value $(
        (Invoke-Expression ('$array{0}Computers61' -f $listItem.Split(':')[0])) |
        Measure-Object | ForEach-Object {$_.Count}
    )
		
		
    New-Variable -Name ('array{0}Computers60' -f $listItem.Split(':')[0]) -Value $(
        $objVulnReportData | 
        Where-Object {$_.Vuln_Name -match ('{0}' -f $listItem.Split(':')[1]) -and $_.vuln_age -gt 30 -and `
        $_.vuln_age -le 60} | ForEach-Object {$_.ip_address} | Sort-Object -Unique
    )
	
    New-Variable -Name ('int{0}Computers60' -f $listItem.Split(':')[0]) -Value $(
        (Invoke-Expression ('$array{0}Computers60' -f $listItem.Split(':')[0])) |
        Measure-Object | ForEach-Object {$_.Count}
    )
		
	
    New-Variable -Name ('array{0}Computers30' -f $listItem.Split(':')[0]) -Value $($objVulnReportData | 
        Where-Object {$_.Vuln_Name -match ('{0}' -f $listItem.Split(':')[1]) -and $_.vuln_age -lt 30} |
        ForEach-Object {$_.ip_address} | Sort-Object -Unique
    )
		
    New-Variable -Name ('int{0}Computers30' -f $listItem.Split(':')[0]) -Value $(
        (Invoke-Expression ('$array{0}Computers30' -f $listItem.Split(':')[0])) |
        Measure-Object | ForEach-Object {$_.Count}
    )
		
    $objSummaryBuilder | 
        Add-Member -Type NoteProperty -Name 'Date' -Value ('{0}' -f $dtScanDate)
	
    $objSummaryBuilder | 
        Add-Member -Type NoteProperty -Name 'Category' -Value ('{0}' -f $listItem.Split(':')[0])
	
    $objSummaryBuilder | 
        Add-Member -Type NoteProperty -Name 't30' -Value $(
        Invoke-Expression ('$int{0}Computers30' -f $listItem.Split(':')[0])
    ) 
		
    $objSummaryBuilder | 
        Add-Member -Type NoteProperty -Name 't60' -Value $(
        Invoke-Expression ('$int{0}Computers60' -f $listItem.Split(':')[0])
    )
		
    $objSummaryBuilder | 
        Add-Member -Type NoteProperty -Name 't61' -Value $(
        Invoke-Expression ('$int{0}Computers61' -f $listItem.Split(':')[0])
    )
	
    $arraySummaryReport += $objSummaryBuilder
}


if ($OutputType -eq 'Screen') { # Print table to the screen
    $arraySummaryReport | Format-Table -AutoSize -Property *
}

if ($OutputType -eq 'CSV' -and $Summary) {
    $SummaryOutputFile = $OutputFile -Replace '.csv','_Application_Summary.csv'
	
    $arraySummaryReport | Export-Csv -Path $SummaryOutputFile -Append -Encoding ASCII -NoTypeInformation
	
}

# How long did this take?
$dtElapsedTime = New-TimeSpan $dtStartTime $(Get-Date)
Invoke-DebugIt -Msg 'Elapsed time' -Val ('{0}' -f ($dtElapsedTime))

#--------------------------- # Clean Up variables, and take out the trash # ---------------------------#

Compare-Object -ReferenceObject $($baselineLocalVariables.Name) -DifferenceObject $((Get-Variable -Scope 0).Name) |
Where-Object {$_.SideIndicator -eq '=>'} |
ForEach-Object {Remove-Variable -Name ('{0}' -f $_.InputObject) -ErrorAction SilentlyContinue}

[GC]::Collect()  # Force garbage collection

#------------------------------------------------------------------------------------------------------#