Function Export-NessusScanAll 
{
    <#
            .SYNOPSIS
            When you need to download all the scan reports (history) for a scan. Helpful when you need to run the
            Nessus_Vuln_Mgmt report tool against all history for a scan, to get historical reporting and stats.

            .DESCRIPTION
            Downloads all scan history for a particular scan.

            .AUTHOR
            https://github.com/masters274/Vulnerability_Management/

            .PARAMETER Server
            Name of your nessus server. IP address works too. 

            .PARAMETER FolderName
            Name of the virtual folder in the Nessus interface.

            .PARAMETER ScanName
            Name of the scan in Nessus

            .PARAMETER Format
            Download format for each report. Nessus (XML), CSV, and HTML are available. 

            .PARAMETER Credential
            Credentials for a Nessus web UI user that has access to the reports/scans. 

            .EXAMPLE
            Export-NessusScansAll -Server scanner.domain.com -FolderName Monthly 
            -ScanName Basic_Network_Internal_Nets -Format Nessus -Credential $MyCreds
		
            This downloads all the scan reports to the current directory for the "Basic_Network_Internal_Nets" 
            scan, located in the "Monthly" folder.

            .NOTES
            This script requires Posh-Nessus module https://github.com/tenable/Posh-Nessus

            Currently, until Issue # 13 is resolved, you'll need to insert the following code on line 743 of
            file scan.ps1 in the Posh-Nessus module

            if($HistoryID)
            {
            $path = "/scans/$($ScanId)/export?history_id=$($HistoryId)"
            }
    #>
    
    <#
            Version 0.2
            - Function Submit-NessusReportToDatabase : Fixed issue with $dtScanDate
    #>


    Param 
    (
        [Parameter(Mandatory=$true,
        HelpMessage='Provide Nessus server name or IP')]
        [Alias('S')]
        [String]$Server,
		
        [Parameter(Mandatory=$true,
        HelpMessage='Nessus UI folder name')]
        [Alias('FN')]
        [String]$FolderName,
		
        [Parameter(Mandatory=$true,
        HelpMessage='Nessus UI scan name')]
        [Alias('SN')]
        [String]$ScanName,
		
        [Parameter(Mandatory=$true,
        HelpMessage='Export format type')]
        [ValidateSet('Nessus','CSV','HTML')]
        [Alias('F')]
        [String]$Format,
		
        [Parameter(Mandatory=$true,
        HelpMessage='PS Credential object for string credentials')]
        [System.Management.Automation.Credential()]
        [Alias('Cred','C')]
        [PSCredential]$Credential
    )

    $boolShouldContinue = $true
	
    # List all modules that are needed for this function to be successful. 
    $arrayRequiredModules = ('Posh-Nessus')
	
    Try 
    { # Requirement checking...
        foreach ($module in $arrayRequiredModules) 
        {
            if (!(Get-Module -Name $module)) 
            {
                Import-Module -Name $module
            }
        }
    }
    
    Catch 
    {
        Write-Error -Message 'Missing one or more requirements. Exiting.'
        $boolShouldContinue = $false
    }

    if ($boolShouldContinue) 
    { # Really shouldn't ever make it here
	
        $session = New-NessusSession -ComputerName $Server -Credentials $Credential
		
        $folder = Get-NessusFolder -SessionId $session.SessionId | 
        Where-Object {$_.Name -eq ('{0}' -f $FolderName)}
			
        $scan = Get-NessusScan -SessionId $session.SessionId -FolderId $folder.FolderId -Status Completed |
        Where-Object {$_.Name -eq ('{0}' -f $ScanName)}
		
		
        $scan | Show-NessusScanHistory | % {
		
            $FileDate = Get-Date -Date ($_.CreationDate) -UFormat '%Y%m%d'
			
            $strFileName = ('{0}\{1}_{2}.nessus' -f $pwd.Path,$FileDate,$ScanName)
		
		
            Export-NessusScan -Format Nessus -SessionId $session.SessionId `
            -ScanId $scan.ScanId -HistoryID $_.HistoryId -OutFile $strFileName
        }

        Remove-NessusSession -SessionId $session.SessionId
    }
}


Function ConvertFrom-NessusReport {
    <#
            .SYNOPSIS
            Used to create an object for working/searching .nessus files

            .DESCRIPTION
            When you have a new nessus scan, and want/need to manually look thru it like any other object, this
            function is just what you need. 

            .PARAMETER InputFile
            Path to a file. Can be relative.

            .EXAMPLE
            $objectReport = ConvertFrom-NessusReport -InputFile .\MyScan.nessus
			
            This creates a PSObject with the report data for each host. Critical, High, Medium, and Low only

            .NOTES
            Export your .nessus report to local disk, then convert from nessus/XML, to searchable PSObject.
            You could also use the Export-NessusScan to get the file. 

            .LINK
            https://github.com/masters274/Vulnerability_Management

            .INPUTS
            String path value.

            .OUTPUTS
            PSObject.
    #>
	
    # TODO: Connect to Nessus and download the scan. Or maybe just leave it the way it is. 
    
    <#
            Version 0.1 
            Added new fields to the report. Protocol, Port, and Service.
            Create a global variable for the Reported Scan Date.
            Changed some of the properties' data types to match value
    #>
	
    PARAM (
        [CmdletBinding()]
        [Parameter(Mandatory,HelpMessage='Path to .nessus file',Position=0)]
        [ValidateScript({Test-Path -Path $_})]
        [String]$InputFile
    )
	
    begin {
        $baselineLocalVariables = Get-Variable -Scope 0 # everything after this gets cleaned up.
        Write-Host 'Nessus report converter, v0.1'
    }
	
    process {
        # Variables 
        $objVulnReportData = @() 
        $dicRiskValue = @{} # Hash table to convert strings to integer
        $dicRiskValue.Add('none',0)
        $dicRiskValue.Add('low',1)
        $dicRiskValue.Add('medium',2)
        $dicRiskValue.Add('high',3)
        $dicRiskValue.Add('critical',4)

        $file = Get-ChildItem -Path $InputFile
        [xml]$nessusfile = [IO.File]::ReadAllText($file.FullName) # Get-Content too slow... 

        # scan date information from the InputFile
        $strScanTime = $nessusfile.NessusClientData_v2.Report.ReportHost.HostProperties.tag |
        Where-Object {$_.name -eq 'HOST_END'} |
        ForEach-Object {$_.'#text'} | 
        Select-Object -First 1
    
        $strScanTime = $strScanTime -replace ("\s\s+"," ")
    
        [datetime]$dtScanTime = ('{0}/{1}/{2} {3}' -f 
            ($strScanTime.Split(' ')[1]), ($strScanTime.Split(' ')[2]), 
            ($strScanTime.Split(' ')[4]), ($strScanTime.Split(' ')[3])
        )

        # We'll report this for the month to have consistency across all report outputs.
        [datetime]$Global:dtScanDate = Get-Date("$($dtScanTime.Month)/1/$($dtScanTime.Year)") -UFormat '%Y-%m-%d'
        
        # Loop thru the hosts to build some reporting
        foreach ($objHost in $nessusfile.NessusClientData_v2.Report.ReportHost) {

            # Get all report items except info
            $reportItems = $objHost.ReportItem | Where-Object {$_.risk_factor -match 'High|Critical|Medium|Low'}

            # Loop thru the items and get needed info from each
            foreach ($item in $reportItems) {

                # Build and PSObject for each of these and add to our hashtable 
                $objBuilder = New-Object -TypeName PSObject

                # Add the host's properties to the builder object
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'NetBios_Name' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'netbios-name'} | ForEach-Object{$_.'#text'})"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'FQDN' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'host-fqdn'} | ForEach-Object{$_.'#text'})"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'IP_Address' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'host-ip'} | ForEach-Object{$_.'#text'})"
    
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'OS_Family' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'os'} | ForEach-Object{$_.'#text'})"
						 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'OS_Name' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'operating-system'} | ForEach-Object{$_.'#text'})"
				
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Credentialed_Scan' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'Credentialed_Scan'} | ForEach-Object{$_.'#text'})"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'CVE_Count' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'patch-summary-total-cves'} | ForEach-Object{$_.'#text'})"
				 
                <#
                
                        $objBuilder | 
                        Add-Member -Type NoteProperty -Name 'Scan_Date' -Value "$($objHost.HostProperties.tag |
                        Where-Object {$_.name -eq 'HOST_START'} | ForEach-Object{$_.'#text'})"
				
                #>
                
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Scan_Date' -Value $dtScanTime
                
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'MAC' -Value "$($objHost.HostProperties.tag |
                Where-Object {$_.name -eq 'mac-address'} | ForEach-Object{$_.'#text'})"


                # Add information about the vulns on the host
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Vuln_Name' -Value "$($item.plugin_name)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Vuln_Family' -Value "$($item.pluginFamily)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Risk_Factor' -Value "$($item.risk_factor)"
				
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Risk_Value' -Value $($dicRiskValue."$($item.risk_factor)")
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Severity' -Value $([int]$item.severity)
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'CVSS_Base_Score' -Value "$($item.cvss_base_score)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'CVSS_Temporal_Score' -Value "$($item.cvss_temporal_score)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Vuln_Scope' -Value "$($item.plugin_type)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Metasploitable' -Value `
                "$($item.exploit_framework_metasploit)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Exploit_Avail' -Value "$($item.exploit_available)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Exploit_Malware' -Value "$($item.exploited_by_malware)"
				 
                $objBuilder |
                Add-Member -Type NoteProperty -Name 'Vuln_Date' -Value "$($item.vuln_publication_date)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Exploit_Difficulty' -Value "$($item.exploitability_ease)"
				 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Solution' -Value "$($item.solution)"
                 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Protocol' -Value "$($item.protocol)"
                 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Port' -Value $([int]$item.port)
                 
                $objBuilder | 
                Add-Member -Type NoteProperty -Name 'Service' -Value "$($item.svc_name)"

                # Get the age, in days, of the vulnerability
                Try {
                    [int]$intVulnAgeInDays = (New-TimeSpan $($item.vuln_publication_date) $(Get-Date)).Days
                } Catch {
                    [int]$intVulnAgeInDays = $null
                }
                $objBuilder | Add-Member -Type NoteProperty -Name 'Vuln_Age' -Value $intVulnAgeInDays

                # Append this data to our hashtable
                $objVulnReportData += $objBuilder
            }
        }
	
        $objVulnReportData
    }
	
    end {
        #--------------------------- # Clean Up variables, and take out the trash # ---------------------------#

        Compare-Object -ReferenceObject $($baselineLocalVariables.Name) -DifferenceObject `
        $((Get-Variable -Scope 0).Name) |
        Where-Object {$_.SideIndicator -eq '=>'} |
        ForEach-Object {Remove-Variable -Name ('{0}' -f $_.InputObject) -ErrorAction SilentlyContinue}

        [GC]::Collect()  # Force garbage collection

        #------------------------------------------------------------------------------------------------------#
    }
}


Function Submit-NessusReportToDatabase 
{
    param 
    (
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, HelpMessage='Data to filter')]
        $InputObject,
        
        [Parameter(Mandatory=$true, HelpMessage='Database Server Name')]
        [String]$Server,
        
        [Parameter(Mandatory=$true, HelpMessage='Database Name')]
        [String]$Database,
        
        [Parameter(Mandatory=$true, HelpMessage='Database Table Name')]
        [String]$Table,
        
        [PSCredential]$Credential
    )
    
    Begin
    {
        Try
        {
            Test-ModuleLoaded -RequiredModules 'core','Database'
        }
        
        Catch
        {
            Write-Error -Message 'Failed to load required modules!'
        }
        
        #Invoke-VariableBaseLine
    }
    
    Process 
    {
        # Get the column information 
        $strColumnNames = ($InputObject | Get-Member -MemberType NoteProperty).Name
        
        $objFailedItems = @()
        
        Foreach ($record in $InputObject) 
        {            
            # Get the global Scan/Report date that should be set from the object created. 
            if (!$Global:dtScanDate) 
            {
                $dtScanDate = (Get-Date -Year (Get-Date).Year -Month (Get-Date).Month -Day 1)
            }
            
            # Variables : Temp
            $strBuilder = @()
            $strValues = @()
            
            
            Foreach ($column in $strColumnNames) 
            {
                $strBuilder += $column
                $strValues += $record.$column -replace ("'",'')
                
                $newVals = $strValues -join "','" 
                $newVals = $newVals -replace ("^|$","'")
            }
            
            
            # Add the report/scan date to the arrays
            $strBuilder += 'YearID'
            $strBuilder += 'MonthID'
            $strBuilder += 'DayID'
            
            $newVals += (',{0},{1},{2}' -f $dtScanDate.Year, $dtScanDate.Month, $dtScanDate.Day)
        
            $strQuery = ('INSERT INTO {0}.{1} ({2}) VALUES ({3})' -f $Database, $Table,($strBuilder -join ','), $newVals)
            
            
            Try 
            {
                Connect-MsSqlDatabase -Server $Server -Database $Database -Username $($Credential.UserName) `
                -Password $($Credential.GetNetworkCredential().Password) -Query $strQuery | 
                Out-Null
            }
            
            Catch 
            {
                $objFailedItems += $record
                
                Write-Host $strQuery
            }
            
            # Clean up the temp variables
            Remove-Variable strBuilder -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
            Remove-Variable strValues -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
            Remove-Variable newVals -ErrorAction SilentlyContinue -WarningAction SilentlyContinue | Out-Null
        }
        
        $objFailedItems.Count
    }
    
    End 
    {
        #Invoke-VariableBaseLine -Clean
    }
}


Function Get-NessusLatestScanReport
{
    <#
            .Synopsis
            Get the latest, completed, report for a specified scan

            .DESCRIPTION
            Get the latest, completed, report for a specified scan

            .EXAMPLE
            Get-NessusLatestScanReport -Server 'ScanServer.domain.com' -Folder 'Monthly' -Scan 'Basic'

            .EXAMPLE
            Get-NessusLatestScanReport -Server 'ScanServer.domain.com' -Folder 'Monthly' -Scan 'Basic' -Cred $creds
    #>

    <#
            Version 0.?
            - ???
    #>

    [CmdLetBinding()]
    Param
    (
        [Parameter(Mandatory=$true)]
        [ValidateScript({ Test-Connection -ComputerName $_ -Quiet -Count 4 }) ]
        [String] $Server,
        
        [Parameter(Mandatory = $true)]
        [String] $FolderName,
        
        [Parameter(Mandatory = $true)]
        [String] $ScanName,
        
        [ValidateScript({ Split-Path $_ -Parent | Test-Path })]
        [String] $Path,
        
        [Parameter(Mandatory=$true)]
        [PSCredential] $Credential
    )
    
    Begin
    {
        # Baseline our environment 
        Invoke-VariableBaseLine

        # Debugging for scripts
        $Script:boolDebug = $PSBoundParameters.Debug.IsPresent
        
        # List of required modules for this function
        $arrayModulesNeeded = (
            'Core','Posh-Nessus'
        )
        
        # Verify and load required modules
        Test-ModuleLoaded -RequiredModules $arrayModulesNeeded -Quiet
    }
    
    Process
    {
        # Functions
        Function Private:Where-Current
        {
            <#
                    .DESCRIPTION
                    Used to get the current nessus report.

                    .PARAMETER InputObject
                    PS Object of report data.
            #>

            param 
            (
                [Parameter(Mandatory=$true, 
                        ValueFromPipeline=$true, 
                HelpMessage='Data to filter')]
                $InputObject
            )

            IF ($InputObject.Status -eq 'Completed')
            {
                $InputObject | Sort-Object -Property CreationDate -Descending |
                Select-Object -First 1
            }
        }
        
        # Variables
        # [String] $strTempFileName = [Guid]::NewGuid().ToString('d')
        # [String] $strTempFilePath = ('{0}\{1}' -f $env:TEMP,$strTempFileName)
        [String] $strFolderName = $FolderName

        $objNessusCred = $Credential
        $session = New-NessusSession -ComputerName scanner.ffsb.com -Credentials $objNessusCred 
        
        $folder = Get-NessusFolder -SessionId $session.SessionId | 
        Where-Object {$_.Name -eq ('{0}' -f $strFolderName)}

        $scan = Get-NessusScan -SessionId $session.SessionId -FolderId $folder.FolderId -Status Completed |
        Where-Object {$_.Name -eq $ScanName}
            
        $history = $scan | Show-NessusScanHistory 
        
        # Get the latest report from the current month, if finished. 
        $currentReport = $history | Where-Current
        
        # Default path to working directory, date and name of the scan report. 
        IF (!$Path)
        {
            $Path = ('{0}\{1}_{2}.nessus' -f $PWD.Path, 
                $(Get-Date -Date $currentReport.CreationDate -UFormat '%Y%m%d'),
                $ScanName
            )
        }
        
        # Export the report, and store it in the temp directory.
        IF ($currentReport.UUID.Length -gt 0)
        {
            Export-NessusScan -Format Nessus -SessionId $session.SessionId `
            -ScanId $scan.ScanId -HistoryID $_.HistoryId -OutFile $Path
        }
        
        Else
        {
            Write-Error -Message 'Failed to get a current scan'
        }
    }
    
    End
    {
        # Clean up the environment
        Invoke-VariableBaseLine -Clean
    }
}